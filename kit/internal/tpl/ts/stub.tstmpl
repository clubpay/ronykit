{{ define "dto" }}
	// {{.Name}} is a data transfer object
	{{ range .Comments -}}
	// {{.}}
	{{ end -}}
	type {{.Name}} struct {
		{{- range .Fields -}}
		{{- if .IsDTO }}
			{{- if .Embedded }}
				{{.Name}}
			{{- else }}
				{{.Name}} {{.Type}} {{ if gt (len .Tags) 0 }}`{{ range .Tags -}}{{.Name}}:"{{.Value}}"{{- end }}`{{- end }}
			{{- end }}
		{{- else }}
			{{.Name}} {{.Type}} {{ if gt (len .Tags) 0 }}`{{ range .Tags -}}{{.Name}}:"{{.Value}}"{{- end }}`{{- end }}
		{{- end }}
		{{- end }}
	}
	{{ if .IsErr }}
	{{- if ne .CodeField ""}}
	func (x {{.Name}}) GetCode() int {
		return x.{{.CodeField}}
	}
	{{- end }}
	{{ if ne .ItemField ""}}
	func (x {{.Name}}) GetItem() string {
		return x.{{.ItemField}}
	}
	{{- end }}
	{{- end }}
{{ end }}
// Code generated by RonyKIT Stub Generator (Golang); DO NOT EDIT.

package {{.Pkg}}

import (
	"context"
	"fmt"

	"github.com/clubpay/ronykit/kit"
	"github.com/clubpay/ronykit/kit/stub"
	"github.com/clubpay/ronykit/kit/utils/reflector"
)

var _ fmt.Stringer

{{$tags := strQuote .Tags}}
func init() {
{{- range $dtoName, $dto := .DTOs }}
reflector.Register(&{{$dtoName}}{}, {{strJoin $tags ","}})
{{- end }}
}

{{ range $dtoName, $dto := .DTOs }}
{{ template "dto" $dto }}
{{ end }}

{{$serviceName := .Name}}
type I{{$serviceName}}Stub interface {
	{{ range .RESTs }}
	{{$methodName := .Name}}
	{{- if ne $methodName "" -}}
	{{$methodName}}(
		ctx context.Context, req *{{.Request.Name}}, opt ...stub.RESTOption,
	) (*{{.Response.Name}}, *stub.Error)
	{{- end -}}
	{{- end }}
}

// {{$serviceName}}Stub represents the client/stub for {{$serviceName}}.
// Implements I{{$serviceName}}Stub
type {{$serviceName}}Stub struct {
    hostPort string
    secure bool
    verifyTLS bool

		s *stub.Stub
}

func New{{$serviceName}}Stub(hostPort string, opts ...stub.Option) *{{$serviceName}}Stub {
    s := &{{$serviceName}}Stub{
			s: stub.New(hostPort, opts...),
		}

    return s
}

var _ I{{$serviceName}}Stub = (*{{$serviceName}}Stub)(nil)

{{ range .RESTs }}
{{$methodName := .Name}}
{{- if ne $methodName "" }}
func (s {{$serviceName}}Stub) {{$methodName}}(
	ctx context.Context, req *{{.Request.Name}}, opt ...stub.RESTOption,
) (*{{.Response.Name}}, *stub.Error){
	res := &{{.Response.Name}}{}
	httpCtx := s.s.REST(opt...).
		SetMethod("{{.Method}}").
		{{ range $idx, $errDto := .PossibleErrors }}
		SetResponseHandler(
			{{ $errDto.Code }},
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				res := &{{$errDto.DTO.Name}}{}
				err := stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))
				if err != nil {
					return err
				}

				return stub.NewErrorWithMsg(res)
			},
		).
		{{- end }}
		SetOKHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				return stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))
			},
		).
		DefaultResponseHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				return stub.NewError(r.StatusCode(), string(r.GetBody()))
			},
		).
		AutoRun(ctx, "{{.Path}}", {{.Encoding}}, req)
	defer httpCtx.Release()

	if err := httpCtx.Err(); err != nil {
		return nil, err
	}

	return res, nil
}
{{ end }}
{{- end }}

type MockOption func(*{{$serviceName}}StubMock)

{{ range .RESTs }}
{{$methodName := .Name}}
{{- if ne $methodName "" }}
func Mock{{$methodName}}(
	f func(ctx context.Context, req *{{.Request.Name}}, opt ...stub.RESTOption) (*{{.Response.Name}}, *stub.Error),
) MockOption {
	return func(sm *{{$serviceName}}StubMock) {
			sm.{{toLower $methodName}} = f
	}
}
{{ end }}
{{- end }}


// {{$serviceName}}StubMock represents the mocked for client/stub for {{$serviceName}}.
// Implements I{{$serviceName}}Stub
type {{$serviceName}}StubMock struct {
{{ range .RESTs }}
	{{$methodName := .Name}}
	{{- if ne $methodName "" -}}
	{{toLower $methodName}} func(ctx context.Context, req *{{.Request.Name}}, opt ...stub.RESTOption) (*{{.Response.Name}}, *stub.Error)
	{{- end -}}
{{- end }}
}

func New{{$serviceName}}StubMock(opts ...MockOption) *{{$serviceName}}StubMock {
    s := &{{$serviceName}}StubMock{}
		for _, o := range opts {
			o(s)
		}

    return s
}

var _ I{{$serviceName}}Stub = (*{{$serviceName}}StubMock)(nil)

{{ range .RESTs }}
{{$methodName := .Name}}
{{- if ne $methodName "" }}
func (s {{$serviceName}}StubMock) {{$methodName}}(
	ctx context.Context, req *{{.Request.Name}}, opt ...stub.RESTOption,
) (*{{.Response.Name}}, *stub.Error){
	if s.{{toLower $methodName}} == nil {
		return nil, stub.WrapError(fmt.Errorf("method not mocked"))
	}

	return s.{{toLower $methodName}}(ctx, req, opt...)
}
{{ end }}
{{- end }}
