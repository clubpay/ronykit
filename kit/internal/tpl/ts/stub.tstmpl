{{ define "dto" }}
	// {{.Name}} is a data transfer object
	{{ range .Comments -}}
	// {{.}}
	{{ end -}}
	export interface I{{.Name}} {
		{{- range .Fields -}}
		{{- if .IsDTO }}
			{{- if .Embedded }}
				{{.Name}}
			{{- else }}
				{{(index .Tags 0).Value}}: I{{.Type}}
			{{- end }}
		{{- else }}
			{{(index .Tags 0).Value}}: {{.Type}}
		{{- end }}
		{{- end }}
	}
{{ end }}
// Code generated by RonyKIT Stub Generator (Golang); DO NOT EDIT.


{{/*var _ fmt.Stringer*/}}

{{/*{{$tags := strQuote .Tags}}*/}}
{{/*func init() {*/}}
{{/*{{- range $dtoName, $dto := .DTOs }}*/}}
{{/*reflector.Register(&{{$dtoName}}{}, {{strJoin $tags ","}})*/}}
{{/*{{- end }}*/}}
{{/*}*/}}

{{ range $dtoName, $dto := .DTOs }}
{{ template "dto" $dto }}
{{ end }}

{{/*{{$serviceName := .Name}}*/}}
{{/*type I{{$serviceName}}Stub interface {*/}}
{{/*	{{ range .RESTs }}*/}}
{{/*	{{$methodName := .Name}}*/}}
{{/*	{{- if ne $methodName "" -}}*/}}
{{/*	{{$methodName}}(*/}}
{{/*		ctx context.Context, req *{{.Request.Name}}, opt ...stub.RESTOption,*/}}
{{/*	) (*{{.Response.Name}}, *stub.Error)*/}}
{{/*	{{- end -}}*/}}
{{/*	{{- end }}*/}}
{{/*}*/}}

{{/*// {{$serviceName}}Stub represents the client/stub for {{$serviceName}}.*/}}
{{/*// Implements I{{$serviceName}}Stub*/}}
{{/*type {{$serviceName}}Stub struct {*/}}
{{/*    hostPort string*/}}
{{/*    secure bool*/}}
{{/*    verifyTLS bool*/}}

{{/*		s *stub.Stub*/}}
{{/*}*/}}

{{/*func New{{$serviceName}}Stub(hostPort string, opts ...stub.Option) *{{$serviceName}}Stub {*/}}
{{/*    s := &{{$serviceName}}Stub{*/}}
{{/*			s: stub.New(hostPort, opts...),*/}}
{{/*		}*/}}

{{/*    return s*/}}
{{/*}*/}}

{{/*var _ I{{$serviceName}}Stub = (*{{$serviceName}}Stub)(nil)*/}}

{{/*{{ range .RESTs }}*/}}
{{/*{{$methodName := .Name}}*/}}
{{/*{{- if ne $methodName "" }}*/}}
{{/*func (s {{$serviceName}}Stub) {{$methodName}}(*/}}
{{/*	ctx context.Context, req *{{.Request.Name}}, opt ...stub.RESTOption,*/}}
{{/*) (*{{.Response.Name}}, *stub.Error){*/}}
{{/*	res := &{{.Response.Name}}{}*/}}
{{/*	httpCtx := s.s.REST(opt...).*/}}
{{/*		SetMethod("{{.Method}}").*/}}
{{/*		{{ range $idx, $errDto := .PossibleErrors }}*/}}
{{/*		SetResponseHandler(*/}}
{{/*			{{ $errDto.Code }},*/}}
{{/*			func(ctx context.Context, r stub.RESTResponse) *stub.Error {*/}}
{{/*				res := &{{$errDto.DTO.Name}}{}*/}}
{{/*				err := stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))*/}}
{{/*				if err != nil {*/}}
{{/*					return err*/}}
{{/*				}*/}}

{{/*				return stub.NewErrorWithMsg(res)*/}}
{{/*			},*/}}
{{/*		).*/}}
{{/*		{{- end }}*/}}
{{/*		SetOKHandler(*/}}
{{/*			func(ctx context.Context, r stub.RESTResponse) *stub.Error {*/}}
{{/*				return stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))*/}}
{{/*			},*/}}
{{/*		).*/}}
{{/*		DefaultResponseHandler(*/}}
{{/*			func(ctx context.Context, r stub.RESTResponse) *stub.Error {*/}}
{{/*				return stub.NewError(r.StatusCode(), string(r.GetBody()))*/}}
{{/*			},*/}}
{{/*		).*/}}
{{/*		AutoRun(ctx, "{{.Path}}", {{.Encoding}}, req)*/}}
{{/*	defer httpCtx.Release()*/}}

{{/*	if err := httpCtx.Err(); err != nil {*/}}
{{/*		return nil, err*/}}
{{/*	}*/}}

{{/*	return res, nil*/}}
{{/*}*/}}
{{/*{{ end }}*/}}
{{/*{{- end }}*/}}

{{/*type MockOption func(*{{$serviceName}}StubMock)*/}}

{{/*{{ range .RESTs }}*/}}
{{/*{{$methodName := .Name}}*/}}
{{/*{{- if ne $methodName "" }}*/}}
{{/*func Mock{{$methodName}}(*/}}
{{/*	f func(ctx context.Context, req *{{.Request.Name}}, opt ...stub.RESTOption) (*{{.Response.Name}}, *stub.Error),*/}}
{{/*) MockOption {*/}}
{{/*	return func(sm *{{$serviceName}}StubMock) {*/}}
{{/*			sm.{{toLower $methodName}} = f*/}}
{{/*	}*/}}
{{/*}*/}}
{{/*{{ end }}*/}}
{{/*{{- end }}*/}}


{{/*// {{$serviceName}}StubMock represents the mocked for client/stub for {{$serviceName}}.*/}}
{{/*// Implements I{{$serviceName}}Stub*/}}
{{/*type {{$serviceName}}StubMock struct {*/}}
{{/*{{ range .RESTs }}*/}}
{{/*	{{$methodName := .Name}}*/}}
{{/*	{{- if ne $methodName "" -}}*/}}
{{/*	{{toLower $methodName}} func(ctx context.Context, req *{{.Request.Name}}, opt ...stub.RESTOption) (*{{.Response.Name}}, *stub.Error)*/}}
{{/*	{{- end -}}*/}}
{{/*{{- end }}*/}}
{{/*}*/}}

{{/*func New{{$serviceName}}StubMock(opts ...MockOption) *{{$serviceName}}StubMock {*/}}
{{/*    s := &{{$serviceName}}StubMock{}*/}}
{{/*		for _, o := range opts {*/}}
{{/*			o(s)*/}}
{{/*		}*/}}

{{/*    return s*/}}
{{/*}*/}}

{{/*var _ I{{$serviceName}}Stub = (*{{$serviceName}}StubMock)(nil)*/}}

{{/*{{ range .RESTs }}*/}}
{{/*{{$methodName := .Name}}*/}}
{{/*{{- if ne $methodName "" }}*/}}
{{/*func (s {{$serviceName}}StubMock) {{$methodName}}(*/}}
{{/*	ctx context.Context, req *{{.Request.Name}}, opt ...stub.RESTOption,*/}}
{{/*) (*{{.Response.Name}}, *stub.Error){*/}}
{{/*	if s.{{toLower $methodName}} == nil {*/}}
{{/*		return nil, stub.WrapError(fmt.Errorf("method not mocked"))*/}}
{{/*	}*/}}

{{/*	return s.{{toLower $methodName}}(ctx, req, opt...)*/}}
{{/*}*/}}
{{/*{{ end }}*/}}
{{/*{{- end }}*/}}
