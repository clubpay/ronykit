// Code generated by RonyKIT Stub Generator (Golang); DO NOT EDIT.

package sampleservice

import (
	"context"
	"fmt"

	"github.com/clubpay/ronykit/kit"
	"github.com/clubpay/ronykit/kit/utils"
	"github.com/clubpay/ronykit/kit/utils/reflector"
	"github.com/clubpay/ronykit/stub"
)

var (
	_ fmt.Stringer
	_ utils.Result
)

func init() {
	reflector.Register(&EchoRequest{}, "json")
	reflector.Register(&EchoResponse{}, "json")
	reflector.Register(&EmbeddedHeader{}, "json")
	reflector.Register(&ErrorMessage{}, "json")
	reflector.Register(&RedirectRequest{}, "json")
	reflector.Register(&SumRequest{}, "json")
	reflector.Register(&SumResponse{}, "json")
}

type IStub interface {
	EchoGET(
		ctx context.Context,
		req *EchoRequest,
		opt ...stub.RESTOption,
	) (*EchoResponse, error)

	EchoPOST(
		ctx context.Context,
		req *EchoRequest,
		opt ...stub.RESTOption,
	) (*EchoResponse, error)

	Sum1(
		ctx context.Context,
		req *SumRequest,
		opt ...stub.RESTOption,
	) (*SumResponse, error)

	Sum2(
		ctx context.Context,
		req *SumRequest,
		opt ...stub.RESTOption,
	) (*SumResponse, error)

	SumRedirect(
		ctx context.Context,
		req *SumRequest,
		opt ...stub.RESTOption,
	) (*SumResponse, error)

	Upload(
		ctx context.Context,
		req kit.MultipartFormMessage,
		opt ...stub.RESTOption,
	) (kit.RawMessage, error)
}

// EchoRequest is a data transfer object
type EchoRequest struct {
	RandomID         int64   `json:"randomID" swag:""`
	Ok               bool    `json:"ok" swag:""`
	OptionalStrField *string `json:"optionalField" swag:"enum:a,b,c"`
	OptionalIntField *int64  `json:"optionalIntField" swag:""`
}

type EchoRequest_OptionalStrFieldENUM string

const (
	EchoRequest_OptionalStrField_A = "a"
	EchoRequest_OptionalStrField_B = "b"
	EchoRequest_OptionalStrField_C = "c"
)

// EchoResponse is a data transfer object
type EchoResponse struct {
	RandomID         int64   `json:"randomID" swag:""`
	Ok               bool    `json:"ok" swag:""`
	OptionalStrField *string `json:"optionalField" swag:""`
	OptionalIntField *int64  `json:"optionalIntField" swag:""`
}

// EmbeddedHeader is a data transfer object
type EmbeddedHeader struct {
	SomeKey1 string `json:"someKey1" swag:""`
	SomeInt1 int64  `json:"someInt1" swag:""`
}

// ErrorMessage is a data transfer object
type ErrorMessage struct {
	Code int    `json:"code" swag:""`
	Item string `json:"item" swag:""`
}

func (x ErrorMessage) GetCode() int {
	return x.Code
}

func (x ErrorMessage) GetItem() string {
	return x.Item
}

// RedirectRequest is a data transfer object
type RedirectRequest struct {
	URL string `json:"url" swag:""`
}

// SumRequest is a data transfer object
type SumRequest struct {
	EmbeddedHeader
	Val1 int64 `json:"val1" swag:""`
	Val2 int64 `json:"val2" swag:""`
}

// SumResponse is a data transfer object
type SumResponse struct {
	EmbeddedHeader
	Val int64 `json:"val" swag:""`
}

// Stub represents the client/stub for .
// Implements IStub
type Stub struct {
	hostPort  string
	secure    bool
	verifyTLS bool

	s *stub.Stub
}

func NewStub(hostPort string, opts ...stub.Option) *Stub {
	s := &Stub{
		s: stub.New(hostPort, opts...),
	}

	return s
}

var _ IStub = (*Stub)(nil)

func (s Stub) EchoGET(
	ctx context.Context, req *EchoRequest, opt ...stub.RESTOption,
) (*EchoResponse, error) {

	res := &EchoResponse{}

	httpCtx := s.s.REST(opt...).
		SetMethod("GET").
		SetResponseHandler(
			400,
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				res := &ErrorMessage{}
				err := stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))
				if err != nil {
					return err
				}

				return stub.NewErrorWithMsg(res)
			},
		).
		SetOKHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {

				return stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))

			},
		).
		DefaultResponseHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				return stub.NewError(r.StatusCode(), string(r.GetBody()))
			},
		).
		AutoRun(ctx, "/echo/{randomID}", kit.CustomEncoding("json"), req)
	defer httpCtx.Release()

	if err := httpCtx.Err(); err != nil {
		return nil, err
	}

	return res, nil
}

func (s Stub) EchoPOST(
	ctx context.Context, req *EchoRequest, opt ...stub.RESTOption,
) (*EchoResponse, error) {

	res := &EchoResponse{}

	httpCtx := s.s.REST(opt...).
		SetMethod("POST").
		SetResponseHandler(
			400,
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				res := &ErrorMessage{}
				err := stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))
				if err != nil {
					return err
				}

				return stub.NewErrorWithMsg(res)
			},
		).
		SetOKHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {

				return stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))

			},
		).
		DefaultResponseHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				return stub.NewError(r.StatusCode(), string(r.GetBody()))
			},
		).
		AutoRun(ctx, "/echo-post", kit.CustomEncoding("json"), req)
	defer httpCtx.Release()

	if err := httpCtx.Err(); err != nil {
		return nil, err
	}

	return res, nil
}

func (s Stub) Sum1(
	ctx context.Context, req *SumRequest, opt ...stub.RESTOption,
) (*SumResponse, error) {

	res := &SumResponse{}

	httpCtx := s.s.REST(opt...).
		SetMethod("GET").
		SetResponseHandler(
			400,
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				res := &ErrorMessage{}
				err := stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))
				if err != nil {
					return err
				}

				return stub.NewErrorWithMsg(res)
			},
		).
		SetOKHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {

				return stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))

			},
		).
		DefaultResponseHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				return stub.NewError(r.StatusCode(), string(r.GetBody()))
			},
		).
		AutoRun(ctx, "/sum/{val1}/{val2}", kit.CustomEncoding("json"), req)
	defer httpCtx.Release()

	if err := httpCtx.Err(); err != nil {
		return nil, err
	}

	return res, nil
}

func (s Stub) Sum2(
	ctx context.Context, req *SumRequest, opt ...stub.RESTOption,
) (*SumResponse, error) {

	res := &SumResponse{}

	httpCtx := s.s.REST(opt...).
		SetMethod("POST").
		SetResponseHandler(
			400,
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				res := &ErrorMessage{}
				err := stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))
				if err != nil {
					return err
				}

				return stub.NewErrorWithMsg(res)
			},
		).
		SetOKHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {

				return stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))

			},
		).
		DefaultResponseHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				return stub.NewError(r.StatusCode(), string(r.GetBody()))
			},
		).
		AutoRun(ctx, "/sum", kit.CustomEncoding("json"), req)
	defer httpCtx.Release()

	if err := httpCtx.Err(); err != nil {
		return nil, err
	}

	return res, nil
}

func (s Stub) SumRedirect(
	ctx context.Context, req *SumRequest, opt ...stub.RESTOption,
) (*SumResponse, error) {

	res := &SumResponse{}

	httpCtx := s.s.REST(opt...).
		SetMethod("GET").
		SetResponseHandler(
			400,
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				res := &ErrorMessage{}
				err := stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))
				if err != nil {
					return err
				}

				return stub.NewErrorWithMsg(res)
			},
		).
		SetOKHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {

				return stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))

			},
		).
		DefaultResponseHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				return stub.NewError(r.StatusCode(), string(r.GetBody()))
			},
		).
		AutoRun(ctx, "/sum-redirect/{val1}/{val2}", kit.CustomEncoding("json"), req)
	defer httpCtx.Release()

	if err := httpCtx.Err(); err != nil {
		return nil, err
	}

	return res, nil
}

func (s Stub) Upload(
	ctx context.Context, req kit.MultipartFormMessage, opt ...stub.RESTOption,
) (kit.RawMessage, error) {

	res := kit.RawMessage{}

	httpCtx := s.s.REST(opt...).
		SetMethod("POST").
		SetResponseHandler(
			400,
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				res := &ErrorMessage{}
				err := stub.WrapError(kit.UnmarshalMessage(r.GetBody(), res))
				if err != nil {
					return err
				}

				return stub.NewErrorWithMsg(res)
			},
		).
		SetOKHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {

				res = utils.CloneBytes(r.GetBody())
				return nil

			},
		).
		DefaultResponseHandler(
			func(ctx context.Context, r stub.RESTResponse) *stub.Error {
				return stub.NewError(r.StatusCode(), string(r.GetBody()))
			},
		).
		AutoRun(ctx, "/upload", kit.CustomEncoding("json"), req)
	defer httpCtx.Release()

	if err := httpCtx.Err(); err != nil {
		return nil, err
	}

	return res, nil
}

type MockOption func(*StubMock)

func MockEchoGET(
	f func(
		ctx context.Context,
		req *EchoRequest,
		opt ...stub.RESTOption,
	) (*EchoResponse, error),
) MockOption {
	return func(sm *StubMock) {
		sm.echoget = f
	}
}

func MockEchoPOST(
	f func(
		ctx context.Context,
		req *EchoRequest,
		opt ...stub.RESTOption,
	) (*EchoResponse, error),
) MockOption {
	return func(sm *StubMock) {
		sm.echopost = f
	}
}

func MockSum1(
	f func(
		ctx context.Context,
		req *SumRequest,
		opt ...stub.RESTOption,
	) (*SumResponse, error),
) MockOption {
	return func(sm *StubMock) {
		sm.sum1 = f
	}
}

func MockSum2(
	f func(
		ctx context.Context,
		req *SumRequest,
		opt ...stub.RESTOption,
	) (*SumResponse, error),
) MockOption {
	return func(sm *StubMock) {
		sm.sum2 = f
	}
}

func MockSumRedirect(
	f func(
		ctx context.Context,
		req *SumRequest,
		opt ...stub.RESTOption,
	) (*SumResponse, error),
) MockOption {
	return func(sm *StubMock) {
		sm.sumredirect = f
	}
}

func MockUpload(
	f func(
		ctx context.Context,
		req kit.MultipartFormMessage,
		opt ...stub.RESTOption,
	) (kit.RawMessage, error),
) MockOption {
	return func(sm *StubMock) {
		sm.upload = f
	}
}

// StubMock represents the mocked for client/stub for .
// Implements IStub
type StubMock struct {
	echoget func(
		ctx context.Context,
		req *EchoRequest,
		opt ...stub.RESTOption,
	) (*EchoResponse, error)

	echopost func(
		ctx context.Context,
		req *EchoRequest,
		opt ...stub.RESTOption,
	) (*EchoResponse, error)

	sum1 func(
		ctx context.Context,
		req *SumRequest,
		opt ...stub.RESTOption,
	) (*SumResponse, error)

	sum2 func(
		ctx context.Context,
		req *SumRequest,
		opt ...stub.RESTOption,
	) (*SumResponse, error)

	sumredirect func(
		ctx context.Context,
		req *SumRequest,
		opt ...stub.RESTOption,
	) (*SumResponse, error)

	upload func(
		ctx context.Context,
		req kit.MultipartFormMessage,
		opt ...stub.RESTOption,
	) (kit.RawMessage, error)
}

func NewStubMock(opts ...MockOption) *StubMock {
	s := &StubMock{}
	for _, o := range opts {
		o(s)
	}

	return s
}

var _ IStub = (*StubMock)(nil)

func (s *StubMock) EchoGET(
	ctx context.Context,
	req *EchoRequest,
	opt ...stub.RESTOption,
) (*EchoResponse, error) {
	if s.echoget == nil {
		return nil, stub.WrapError(fmt.Errorf("method not mocked"))
	}

	return s.echoget(ctx, req, opt...)
}

func (s *StubMock) SetEchoGET(
	f func(
		ctx context.Context,
		req *EchoRequest,
		opt ...stub.RESTOption,
	) (*EchoResponse, error),
) *StubMock {
	s.echoget = f

	return s
}

func (s *StubMock) EchoPOST(
	ctx context.Context,
	req *EchoRequest,
	opt ...stub.RESTOption,
) (*EchoResponse, error) {
	if s.echopost == nil {
		return nil, stub.WrapError(fmt.Errorf("method not mocked"))
	}

	return s.echopost(ctx, req, opt...)
}

func (s *StubMock) SetEchoPOST(
	f func(
		ctx context.Context,
		req *EchoRequest,
		opt ...stub.RESTOption,
	) (*EchoResponse, error),
) *StubMock {
	s.echopost = f

	return s
}

func (s *StubMock) Sum1(
	ctx context.Context,
	req *SumRequest,
	opt ...stub.RESTOption,
) (*SumResponse, error) {
	if s.sum1 == nil {
		return nil, stub.WrapError(fmt.Errorf("method not mocked"))
	}

	return s.sum1(ctx, req, opt...)
}

func (s *StubMock) SetSum1(
	f func(
		ctx context.Context,
		req *SumRequest,
		opt ...stub.RESTOption,
	) (*SumResponse, error),
) *StubMock {
	s.sum1 = f

	return s
}

func (s *StubMock) Sum2(
	ctx context.Context,
	req *SumRequest,
	opt ...stub.RESTOption,
) (*SumResponse, error) {
	if s.sum2 == nil {
		return nil, stub.WrapError(fmt.Errorf("method not mocked"))
	}

	return s.sum2(ctx, req, opt...)
}

func (s *StubMock) SetSum2(
	f func(
		ctx context.Context,
		req *SumRequest,
		opt ...stub.RESTOption,
	) (*SumResponse, error),
) *StubMock {
	s.sum2 = f

	return s
}

func (s *StubMock) SumRedirect(
	ctx context.Context,
	req *SumRequest,
	opt ...stub.RESTOption,
) (*SumResponse, error) {
	if s.sumredirect == nil {
		return nil, stub.WrapError(fmt.Errorf("method not mocked"))
	}

	return s.sumredirect(ctx, req, opt...)
}

func (s *StubMock) SetSumRedirect(
	f func(
		ctx context.Context,
		req *SumRequest,
		opt ...stub.RESTOption,
	) (*SumResponse, error),
) *StubMock {
	s.sumredirect = f

	return s
}

func (s *StubMock) Upload(
	ctx context.Context,
	req kit.MultipartFormMessage,
	opt ...stub.RESTOption,
) (kit.RawMessage, error) {
	if s.upload == nil {
		return nil, stub.WrapError(fmt.Errorf("method not mocked"))
	}

	return s.upload(ctx, req, opt...)
}

func (s *StubMock) SetUpload(
	f func(
		ctx context.Context,
		req kit.MultipartFormMessage,
		opt ...stub.RESTOption,
	) (kit.RawMessage, error),
) *StubMock {
	s.upload = f

	return s
}
